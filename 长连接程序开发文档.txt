time:2014:07:17
18:26
事件：出现套接字地址重复使用问题,在server->Start();处出现了异常；
获取本地ip方法出现问题___以上两处问题已经解决。由于当前一次进程未关闭编译时会报错

time:2014:07:22
21:58
事件：异步调用接收/发送数据的语法问题
有关调用实时(JIT)调试而不是此对话框的详细信息，
请参见此消息的结尾。

************** 异常文本 **************
System.NullReferenceException: 未将对象引用设置到对象的实例。
   ......
</configuration>

启用 JIT 调试后，任何未经处理的异常
都将被发送到在此计算机上注册的 JIT 调试器，
而不是由此对话框处理。
::上面问题是由于使用 client->GetStream()->BeginRead(data, 0, data->Length, tcpRecvCallback, this);
与form1->client = form1->server->EndAcceptTcpClient(ar);不匹配造成的，应改为
 server->BeginAcceptTcpClient(tcpRecvCallback, this);

、、、、、、、、、、、、、、、、、、、、、、、、、
2014.7.23
298行出现无法访问已释放对象
解决：缺乏检错机制导致客户端未连接时会出现无法访问以释放对象的情况
2014.7.25
跨线程访问控件问题:public变量，用线程更新变量。创建一个timer，定时获取变量显示在控件上
单击任何按钮会触发异步事件问题
检错机制的设定
2014.7.28
跨线程访问控件问题:public变量，用线程更新变量。创建一个timer，定时获取变量显示在控件上
单击任何按钮会触发异步事件问题
检错机制的设定
判断对方已经处于掉线状态，此时不在读取数据流，而是放弃当前连接创建新的连接

07.31
17:23
数据流的判断，判断流中是否有数据，有则连接存在没有则连接中断
a:使用try，catch机制。连接被意外断开是另一方则重新建立连接
由于处于连续的发送接收状态，CPU的占用率会很高，应选择适当的时间让线程假死，或者使用线程定时器。出于简单性考虑
在程序中时候用了假死Threading::Sleep();来减少CPu的负担
//////////////////////////////////////////////////////////
实现原理：
实现服务端和客户端的长连接
关键是断线重连的方法，主要通过双发在一定的时间间隔内发送数据包。以接受到与否
来判断连接是否正常

服务端实现原理：
获取本地IP，绑定在server上
开始监听客户端连接请求
判断是否有挂起的连接请求
开始接受客户端连接请求
判断是否连接成功
是则开始检测连接是否中断
是则关闭当前服务器，重新创建服务器
开始监听
开始接受连接
继续检测连接情况

客户端实现原理：
创建客户端
填充服务端IP
发送连接请求
检测连接是否成功
检测连接是否中断
是则放弃当前连接，重新创建客户端
填充服务端IP
发送连接请求
继续检测连接是否中断